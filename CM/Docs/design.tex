\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage{alltt,amsmath,hyperref,graphicx}

\title{Concurrency and Multithreading - Design}

\author{Jayke Meijer, 2526284, \url{jayke.meijer@gmail.com} \\
Tadde\"us Kroes, , \url{}}

\def\bigoh{\mathcal{O}}

\begin{document}

\maketitle
\pagebreak

\tableofcontents
\pagebreak

\section{Introduction}

This document discusses the design of several concurrent data
structures. Both an advanced design and a discussion about the
expected performance will be given for each data structure.

The data structures are the following: CoarseGrainedList,
CoarseGrainedTree, FineGrainedList, FineGrainedTree,
LockFreeList and LockFreeTree.

The difficulty with these data structures is that they are
accessed by several threads concurrently, so mutual exclusion has
to be provided for the parts where the updates take place.

\section{CoarseGrainedList}

The first data structure discussed is the CoarseGrainedList.
This is a singly-linked list. When an element is added or removed,
the entire data structure is locked.

\subsection{Design}

For the CoarseGrainedList a singly-linked list is required. To create this
list a sequence of nodes is used. These nodes contain both the stored items
and a link to the next node in the list.

To lock the list when an \emph{add} or \emph{remove} operation is performed,
a single lock is required. The lock is acquired in the beginning of the
operation. Once the lock is obtained, either the position to insert the new
node or the node to remove is located, and the remove or insert operation is
performed. Once this is done, the lock is released, allowing
other threads to do their operations.

\subsection{Performance}

The performance of the CoarseGrainedList is expected to be very poor. Almost
no parallel execution is possible, due to the fact that the entire
data structure is locked during the entire add or remove operation. This means
that whenever one thread is performing such an operation, no other thread can
do such an operation, but also not even prepare this operation, by for example
locating the nodes affected.

This means that regardless of the number of elements in the data structure,
only one thread at a time can access the list. The performance is therefore
expected to be very poor when a lot of threads are trying to execute a lot
of operations on the list.

The complexity for a single thread will be $\bigoh(n)$ with $n$ being
the number of elements in the list, since
locating the affected nodes means in worst case looping through the entire
list.

Since no parallel execution of the operations is possible, the worst-case
complexity of the entire algorithm is expected to be $\bigoh(n * m)$,
with $n$ the number of elements and $m$ the number of threads.

\section{CoarseGrainedTree}

The CoarseGrainedTree is a binary search tree. As with the
CoarseGrainedList, the complete data structure is locked when
an add or remove is performed.

\subsection{Design}

The design of the CoarseGrainedTree is comparable with the design of the
CoarseGrainedList. However, the nodes used now have up to two child nodes
instead of a single following node.

The locking mechanism remains the same, the entire tree is locked before
an add or remove operation is performed. Again, the operation performed
during the lock includes the locating of the affected nodes.

For the addition of nodes we use an algorithm as described here:
\url{http://www.algolist.net/Data_structures/Binary_search_tree/Insertion}.
The removal is done with the algorithm as described here:
\url{http://www.algolist.net/Data_structures/Binary_search_tree/Removal}.

\subsection{Performance}

As with the CoarseGrainedList, the performance will be poor when a lot of
threads try to perform operations simultaneously.

The locating of the affected nodes will be faster, since we are dealing
with a binary tree instead of a list. Therefore the overall performance
will be better, due to the fact that the basic algorithm is more effective.

The complexity of a single thread is in the worst-case the same as with the
linked list, when the tree is completely unbalanced, so $\bigoh(n)$.
However, the average complexity will be better than that, and better than the
average complexity of the linked list.

If the tree is completely balanced, the complexity will be
$\bigoh(log n)$.

Once again, these complexities are to be multiplied with the number of
threads, giving $\bigoh(n * m)$ and $\bigoh(log(n) * m)$
respectively.

\section{FineGrainedList}

The FineGrainedList is a linked list that only locks a part of
the data structure when performing an add or remove operation. This
gives it the ability to have several threads update the list at the
same time.

\subsection{Design}

The locking is done as follows. A node is locked before its value is checked.
When it is decided that this node is not yet the required node, the next node
is locked first, before the lock on the current node is released. This way
it is guaranteed that a node can not be removed between checking its value and
the actual operation on the node. This is called \emph{Hand-over-hand} locking.

\subsection{Performance}

The advantage of this data structure is expected to be better than that of the
CoarseGrainedList, since multiple threads can operate on the list at the same
time.

However, there are some remarks to be made. The result of the 
\emph{hand-over-hand} locking is that a thread can not pass another thread
while traversing the list. This causes a delay when elements are added/removed
in ascending order. Each thread will then still have to wait on the thread in
front of him. The only advantage over the CoarseGrainedList is that while
it is waiting for the other list, it is already on its way to the proper node.

The advantage of the FineGrainedList as opposed to the CoarseGrainedList will
probably grow with the size of the list. In the FineGrainedList, part of an
operation can be performed before a locked element is encountered, whereas the
CoarseGrainedList blocks the list altogether.

However, when no two threads are accessing the list at the same time, the
FineGrainedList will have some lock overhead because elements are locked
individually. Since the test application does not add pauses between
adding/removing different elements, this case will probably not occur in the
benchmark results.

\section{FineGrainedTree}

The FineGrainedTree is a tree in which only a part of the data structure
will be locked for add or remove operations, as with the FineGrainedList.

\subsection{Design}

The design of the lock mechanism in the FineGrainTree is similar to that of the
FineGrainList. The next node visited is locked before the lock on the current
node can be released. The difference is that the current node locks one of its
child nodes next instead of the singly-linked next node.

\subsection{Performance}

With the FineGrainedList the problem was that while traversing the list, one
thread has to wait for other threads that perform their tasks. With the tree
this happens less often. When the thread A operates in another subtree than
thread B, these threads do not interfere with each other.

This effect is strongest when the tree is well balanced. Like with the
CoarseGrainedTree, when the tree is completely unbalanced it basically is
a linked list. All the advantages of the tree structure are then lost.

To maximize the advantage of a tree structure as opposed to a linked list, the
number of threads should be small in comparison to the number of elements in the
data structure. Assuming that the tree will be balanced to some degree due to the
randomness of the elements added to the tree, there will be minimum interference
between threads.

The root of the tree and first few levels of nodes can be expected to be a
bottleneck, since these will be visited by each thread for every operation.

\section{LockFreeList}

The LockFreeList is a linked list that does not use a lock when updating
the datastructure. Instead it uses a single atomic operation for both
comparing and updating, compare-and-set instructions.

\subsection{Design}

Design of LFL.

\subsection{Performance}

Performance Evaluation of LFL.

\section{LockFreeTree}

The LockFreeTree uses compare-and-set instructions instead of locks.

\subsection{Design}

Design of LFT.

\subsection{Performance}

Performance Evaluation of LFT.

\end{document}