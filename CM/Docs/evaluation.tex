\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{alltt,amsmath,hyperref,graphicx}
\usepackage[usenames,dvipsnames]{xcolor}

% Link colors
\hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,citecolor=OliveGreen}

% Set paragraph indentation
\parindent 0pt
\parskip 1.0ex plus 0.5ex minus 0.2ex

\title{Concurrency and Multithreading - Performance Evaluation}
\author{Jayke Meijer, 2526284, jmr251, \url{jayke.meijer@gmail.com} \\
Taddeüs Kroes, 2526902, tks590, \url{taddeuskroes@gmail.com}}

\def\bigoh{\mathcal{O}}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\section{Introduction}

This document discusses the design and performance of several
concurrent data structures.

The data structures are the following: CoarseGrainedList,
CoarseGrainedTree, FineGrainedList, FineGrainedTree,
LockFreeList and LockFreeTree.

The difficulty with these data structures is that they are accessed by several threads 
concurrently, so it has to be guaranteed that each update succeeds, even when separate
updates by different threads interfere.

The design of the data structures was already given in the design document\cite{design}. 
These will therefore only be discussed on a high level in this performance evaluation. Any
difficulties encountered during the implementation will be discussed.

\section{Implementation difficulties}

\subsection{Lists and CoarseGrainedTree}
Most of the data structures were straightforward to implement. The CoarseGrainedList,
FineGrainedList and LockFreeList were described in the book by Herlihy and 
Shavit\cite{book}. These did therefore not present any problems during the implementation.

The CoarseGrainedTree had to be designed by ourself, but only required the placing of a 
lock mechanism around standard tree insertions and removals. The used algorithms for 
inserting and removing in a Binary Search Tree are based on standard BST operations.
\cite{insert}\cite{delete}

\subsection{FineGrainedTree}

The FineGrainedTree is more of a challenge to implement. The basic idea is the same as the
FineGrainedList. It uses hand-over-hand locking to traverse through the list. However,
instead of locking the successor you first have to determine whether to lock the left or
the right child node.

The challenge is what to do during the removal of an element. When deleting a node that
has two children, the in-order successor of this node has to be found. This is the node
with the smallest value in the right subtree of the node to delete. However, it is 
possible that another thread is performing an operation in this subtree. Therefore 
traversal through this subtree should be done with locking as well, to prevent overtaking
of another thread.

\subsection{LockFreeTree}

The most challenging data structure is the LockFreeTree.

\section{Performance Evaluation}

\section{Conclusion}

\begin{thebibliography}{}    
\bibitem{design}
    Taddeüs Kroes, Jayke Meijer, Concurrency and Multithreading - Design

\bibitem{book}
    Maurice Herlihy \& Nir Shavit, The Art of Multiprocessor Programming. Morgan Kaufmann.         
    2012.

\bibitem{insert}
    Binary Search Tree: Insertion
    \url{http://www.algolist.net/Data_structures/Binary_search_tree/Insertion}
    
\bibitem{delete}
    Binary Search Tree: Removal
    \url{http://www.algolist.net/Data_structures/Binary_search_tree/Removal}
  
\end{thebibliography}

\end{document}