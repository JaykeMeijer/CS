\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{alltt,amsmath,hyperref,graphicx}
\usepackage[usenames,dvipsnames]{xcolor}

% Link colors
\hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,citecolor=OliveGreen}

% Set paragraph indentation
\parindent 0pt
\parskip 1.0ex plus 0.5ex minus 0.2ex

\title{Concurrency and Multithreading - Performance Evaluation}
\author{Jayke Meijer, 2526284, jmr251, \url{jayke.meijer@gmail.com} \\
Taddeüs Kroes, 2526902, tks590, \url{taddeuskroes@gmail.com}}

\def\bigoh{\mathcal{O}}

\begin{document}

\maketitle

\tableofcontents
\pagebreak

\section{Introduction}

This document discusses the design and performance of several
concurrent data structures.

The data structures are the following: CoarseGrainedList,
CoarseGrainedTree, FineGrainedList, FineGrainedTree,
LockFreeList and LockFreeTree.

The difficulty with these data structures is that they are accessed by several threads 
concurrently, so it has to be guaranteed that each update succeeds, even when separate
updates by different threads interfere.

The design of the data structures was already given in the design document\cite{design}. 
These will therefore only be discussed on a high level in this performance evaluation. Any
difficulties encountered during the implementation will be discussed.

\section{Implementation difficulties}

\subsection{Lists and CoarseGrainedTree}
Most of the data structures were straightforward to implement. The CoarseGrainedList,
FineGrainedList and LockFreeList were described in the book by Herlihy and 
Shavit\cite{book}. These did therefore not present any problems during the implementation.

The CoarseGrainedTree had to be designed by ourself, but only required the placing of a 
lock mechanism around standard tree insertions and removals. The used algorithms for 
inserting and removing in a Binary Search Tree are based on standard BST operations.
\cite{insert}\cite{delete}

\subsection{FineGrainedTree}

The FineGrainedTree is more of a challenge to implement. The basic idea is the same as the
FineGrainedList. It uses hand-over-hand locking to traverse through the list. However,
instead of locking the successor you first have to determine whether to lock the left or
the right child node.

The challenge is what to do during the removal of an element. When deleting a node that
has two children, the in-order successor of this node has to be found. This is the node
with the smallest value in the right subtree of the node to delete. However, it is 
possible that another thread is performing an operation in this subtree. Therefore 
traversal through this subtree should be done with locking as well, to prevent overtaking
of another thread.

\subsection{LockFreeTree}

The most challenging data structure is the LockFreeTree. The design is provided in an 
article by Ellen, Ruppert, Fatourou and Van Breugel.\cite{lft} This article describes the
algorithms, gives a pseudocode implementation and proves why it is correct.

The first challenge encountered is that the article uses Compare-And-Swap instructions.
However, Java does not have this operation, it only supports Compare-And-Set instructions.
The difference between these two is that a Compare-And-Swap returns the original value,
even when the operation failed. The Compare-And-Set only returns whether the operation 
succeeded or not.

This is potentially a problem in the \texttt{HelpDelete()} function, where the result of
the CAS operation is not only used to check whether the operation succeeded, but is also
used for another check where it is verified if the node is marked. However, in this
case we can argue that this is not a problem. One of the properties of the design is that
a marked node will never be unmarked or changed. Therefore, if a node is marked, no 
further checks have to be atomic and can be performed without any harm.

Another challenge is that the article stores the \texttt{Update} field in a single CAS
word, and uses a part of this word for the state(only 2 bits) and the rest for the pointer
to the info record. However, this kind of storage is not possible in Java. The solution is
to use the \texttt{AtomicStampedReference<V>} class. This can store a reference to an
object and an integer. The integer can be used to store the state, while the reference 
points to an info object. Both can be read and updated in a single atomic step by
\texttt{get()} and \texttt{compareAndSet()} respectively.

Another challenge that we encountered is the \texttt{Search()} function. In the pseudocode
this function returns five variables. Java only supports the return of one variable, or
you have to create an array of one element, pass it on to the function as an argument and
store the return value in this argument. This would create rather messy code. Our solution 
is to create an object, called \texttt{SearchTuple}. This contains the five values
returned by the search function. That function will now return a SearchTuple.

There is one thing to be aware of with this construction. The pseudocode search function
uses \texttt{gpupdate} and \texttt{pupdate} both internally and as return values. However,
in Java this makes it a reference to the \emph{update} field of the node found. This means
it can be changed by another thread. However, the result returned by search (ie the
searchTuple) should never change. Therefore the \texttt{pupdate} and \texttt{gpupdate} are
cloned in the constructor of the searchTuple, so they do not point to the update field of
a node but to a new, unique, update object.

\section{Performance Evaluation}

\subsection{Used hardware}

The tests have been performed on two different systems. The first is a server at the VU,
reachable at \url{fluit.few.vu.nl}. This machine has eight cores and is suitable for true
parallelism testing. However, due to the high usage on this machine, the performance 
figures are not reliable. This machine is only used to verify that the data structures 
work even when a large number of threads are operating concurrently.

The actual performance tests are done on a machine with an Intel i7 CPU. This machine has
4 cores and multithreading, meaning that the hardware supports 8 concurrent threads (even
though only 4 are actually active). This machine runs Gentoo.

\subsection{Effect of the number of elements}

The first variable in performance that will be evaluated is the number of elements. The
expectation in the design document was that all the lists will perform comparably bad with
lots of elements, since searching through a list costs more time than in a tree. It was 
also expected that the performance would increase in the following order: CoarseGrained,
FineGrained, LockFree.

The actual results are in the following graphs:
\begin{figure}
    %\includegraphics[scale=0.5]{images/}
    \caption{Execution time versus the number of elements, using 4 threads}
    \label{elem_4thread}
\end{figure}
\begin{figure}
    %\includegraphics[scale=0.5]{images/}
    \caption{Execution time versus the number of elements, using 8 threads}
    \label{elem_8thread}
\end{figure}

\subsection{Effect of the number of threads}

The second variable in performance is the number of threads. The expectation was that the
performance was once again improving with the tree, except with the CoarseGrainedTree, 
since no concurrent execution is possible there. The two other trees are expected to
perform better than the lists with a large number of concurrent thread, since once they
operate in a different subtree, threads no longer interfere, were as this does happen in
the list.

The actual result is in the following graph:
\begin{figure}
    %\includegraphics[scale=0.5]{images/}
    \caption{Execution time versus the number of threads, using 5040 elements}
    \label{thread}
\end{figure}

\section{Conclusion}

\begin{thebibliography}{}    
\bibitem{design}
    Taddeüs Kroes, Jayke Meijer, Concurrency and Multithreading - Design

\bibitem{book}
    Maurice Herlihy \& Nir Shavit, The Art of Multiprocessor Programming. Morgan Kaufmann.         
    2012.

\bibitem{insert}
    Binary Search Tree: Insertion
    \url{http://www.algolist.net/Data_structures/Binary_search_tree/Insertion}
    
\bibitem{delete}
    Binary Search Tree: Removal
    \url{http://www.algolist.net/Data_structures/Binary_search_tree/Removal}

\bibitem{lft}
    Faith Ellen, Eric Ruppert, Panagiota Fatourou, Franck van Breugel, Non-blocking Search 
    Trees

\end{thebibliography}
\end{document}